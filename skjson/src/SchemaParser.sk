/*****************************************************************************/
/* Parser for JSON schemas. */
/*****************************************************************************/

module SKJSON;

// Example of schema

//   null
// | number<float>
// | string
// | [number<float> | [null | number<float>]]
// | {
//     ?"field0": string | [] | {"field1": string, "field9": {}},
//     ?"field1": number<float> | string,
//     ?"field3": number<float> | string,
//     ?"field5": number<float>,
//     ?"field7": string,
//     ?"field8": number<float>,
//     ?"field9": number<float>
//   }

class ParserError(msg: String) extends Exception {
  fun getMessage(): String {
    this.msg
  }
}

mutable class Lexer(
  iter: mutable String.StringIterator,
  backBuf: mutable Vector<Char> = mutable Vector[],
) {
  mutable fun next(): ?Char {
    if (this.backBuf.isEmpty()) {
      loop {
        c = this.iter.next();
        c match {
        | None() -> return None()
        | Some(' ')
        | Some('\t')
        | Some('\n') ->
          continue
        | Some(_) -> return c
        }
      }
    };
    Some(this.backBuf.pop())
  }

  mutable fun back(c: Char): void {
    this.backBuf.push(c)
  }
}

mutable class Parser(lex: mutable Lexer) {
  static fun mcreate(str: String): mutable this {
    mutable static(mutable Lexer(str.getIter()))
  }

  static fun normalize(types: mutable Vector<SType>): Type {
    types.sortBy(x ~> x.kind());
    result = mutable Vector[];
    for (ty in types) {
      if (result.isEmpty()) {
        result.push(ty);
        continue;
      };
      last = result[result.size() - 1];
      if (ty.kind() == last.kind()) {
        !last = ty.union(last);
        result![result.size() - 1] = last;
      } else {
        result.push(ty);
        !last = ty;
      }
    };
    Type::createFromItems(
      result.map(x -> (FieldCount::alwaysValue, x)).toArray(),
    )
  }

  mutable fun type(): Type {
    types = mutable Vector[];
    loop {
      sty = this.stype();
      types.push(sty);
      this.lex.next() match {
      | None() -> return static::normalize(types)
      | Some('|') -> continue
      | Some(c) ->
        this.lex.back(c);
        return static::normalize(types)
      }
    }
  }

  mutable fun expect(c: Char): void {
    if (this.lex.next() == Some(c)) return void;
    this.error("Was expecting: " + c)
  }

  mutable fun stype(): SType {
    this.lex.next() match {
    | None() -> this.error("Expected a type")
    | Some('[') ->
      nc = this.lex.next();
      nc match {
      | None() -> this.error("Expected ']'")
      | Some(c) if (c == ']') -> return TArray(Type::createFromItems(Array[]))
      | Some(c) -> this.lex.back(c)
      };
      result = TArray(this.type());
      this.expect(']');
      result
    | Some('{') ->
      fields = mutable Vector[];
      for (fieldName => field in this.fields()) {
        (alwaysPresent, fieldType) = field;
        fields.push(
          if (alwaysPresent) {
            Field(fieldName, FieldCount::always(), fieldType)
          } else {
            Field(fieldName, FieldCount::optional(), fieldType)
          },
        );
      };
      TObject(Fields::create(fields.toArray()))
    | Some(c) ->
      this.lex.back(c);
      kwd = this.nextKeyword();
      kwd match {
      | "null" -> TNull()
      | "bool" -> TBool()
      | "int" -> TInt()
      | "float" -> TFloat()
      | "string" -> TString()
      | x -> this.error("Unknown type: '" + x + "'")
      }
    }
  }

  mutable fun fields(): Map<String, (Bool, Type)> {
    fields = mutable Map[];
    loop {
      this.lex.next() match {
      | None() -> this.error("Expected field")
      | Some('}') -> return fields.chill()
      | Some(c) -> this.lex.back(c)
      };
      (fieldName, (optional, ty)) = this.field();
      fields![fieldName] = (!optional, ty);
      this.lex.next() match {
      | Some(',') -> continue
      | Some('}') -> return fields.chill()
      | _ -> this.error("Expected '}'")
      }
    }
  }

  mutable fun field(): (String, (Bool, Type)) {
    optional = this.lex.next() match {
    | Some('?') ->
      this.lex.next() match {
      | Some('"') -> void
      | _ -> this.error("Expected field name")
      };
      true
    | Some('"') -> false
    | _ -> this.error("Expected field name")
    };
    fieldName = this.nextString();
    this.lex.next() match {
    | Some(':') -> void
    | _ -> this.error("Expected field type")
    };
    ty = this.type();
    (fieldName, (optional, ty))
  }

  readonly fun error<T>(msg: String): T {
    invariant_violation(msg)
  }

  private mutable fun nextString(): String {
    buffer = mutable Vector[];
    loop {
      this.lex.iter.next() match {
      | None()
      | Some('"') ->
        return String::fromChars(buffer.toArray())
      | Some(c @ '\\') ->
        buffer.push(c);
        this.lex.next() match {
        | None() -> invariant_violation("Unterminated string")
        | Some(escaped) -> buffer.push(escaped)
        }
      | Some(c) -> buffer.push(c)
      }
    }
  }

  private mutable fun nextKeyword(): String {
    buffer = mutable Vector[];
    loop {
      ch = this.lex.next();
      ch match {
      | None() -> return String::fromChars(buffer.toArray())
      | Some(c @ '\t')
      | Some(c @ '\n')
      | Some(c @ '|')
      | Some(c @ ',')
      | Some(c @ '<')
      | Some(c @ '>')
      | Some(c @ '}')
      | Some(c @ ']')
      | Some(c @ ' ') ->
        this.lex.back(c);
        return String::fromChars(buffer.toArray())
      | Some(c) -> buffer.push(c)
      }
    }
  }
}
