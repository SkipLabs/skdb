module alias DBUtils = SKDBFormToSKStore;

module SKStore;

@cpp_extern
@debug
native fun applyMapFun(
  fn: UInt32,
  context: mutable Context,
  writer: mutable TWriter<JSONID, JSONFile>,
  key: SKJSON.CJSON,
  values: mutable NonEmptyIterator<JSONFile>,
): void;

@cpp_extern
@debug
native fun applyConvertToRowFun(
  fn: UInt32,
  key: SKJSON.CJSON,
  values: mutable NonEmptyIterator<JSONFile>,
): SKJSON.CJSON;

@cpp_extern
@debug
native fun applyMapTableFun(
  fn: UInt32,
  context: mutable Context,
  writer: mutable TWriter<JSONID, JSONFile>,
  key: SKJSON.CJArray,
  occ: Float,
): void;

@cpp_extern
@debug
native fun init(context: mutable Context): void;

@cpp_extern
@debug
native fun applyLazyFun(
  fn: UInt32,
  context: mutable Context,
  self: LHandle<JSONID, JSONFile>,
  key: SKJSON.CJSON,
): SKJSON.CJSON;

@cpp_extern
@debug
native fun applyParamsFun(
  fn: UInt32,
  context: mutable Context,
  key: SKJSON.CJSON,
): SKJSON.CJSON;

@cpp_extern
@debug
native fun applyLazyAsyncFun(
  fn: UInt32,
  callId: String,
  name: String,
  key: SKJSON.CJSON,
  param: SKJSON.CJSON,
): void;

@cpp_extern
@debug
native fun detachHandle(fn: UInt32): void;

@cpp_extern
@debug
native fun applyAccumulate(
  fn: UInt32,
  acc: SKJSON.CJSON,
  value: SKJSON.CJSON,
): SKJSON.CJSON;

@cpp_extern
@debug
native fun applyDismiss(
  fn: UInt32,
  acc: SKJSON.CJSON,
  value: SKJSON.CJSON,
): ?SKJSON.CJSON;

@cpp_extern
@debug
native fun getErrorHdl(exn: .Exception): Float;

// Exports

@export("SKIP_SKStore_writerSet")
fun writerSet(
  writer: mutable TWriter<JSONID, JSONFile>,
  key: SKJSON.CJSON,
  value: SKJSON.CJSON,
): void {
  writer.set(JSONID(key), JSONFile(value))
}

@export("SKIP_SKStore_writerSetArray")
fun writerSetArray(
  writer: mutable TWriter<JSONID, JSONFile>,
  key: SKJSON.CJSON,
  values: SKJSON.CJArray,
): void {
  files = values match {
  | SKJSON.CJArray(xs) -> xs.map(x -> JSONFile(x))
  };
  writer.setArray(JSONID(key), files)
}

@export("SKIP_SKStore_iteratorFirst")
fun iteratorFirst(values: mutable NonEmptyIterator<JSONFile>): SKJSON.CJSON {
  if (values.isPastFirstValue) {
    throw Error("`first` can't be called after `next` on a NonEmptyIterator")
  };
  values.first.value
}

@export("SKIP_SKStore_iteratorUniqueValue")
fun iteratorUniqueValue(
  values: mutable NonEmptyIterator<JSONFile>,
): ?SKJSON.CJSON {
  value = values.next().map(v -> v.value);
  if (values.next().isSome()) None() else value
}

@export("SKIP_SKStore_iteratorNext")
fun iteratorNext(values: mutable NonEmptyIterator<JSONFile>): ?SKJSON.CJSON {
  values.next().map(v -> v.value)
}

class FnHandle private (eptr: SKStore.ExternalPointer) extends File {
  static fun make(id: UInt32): this {
    static(SKStore.ExternalPointer::create(id, detachHandle))
  }

  fun getId(): UInt32 {
    this.eptr.value
  }

  fun map(
    context: mutable Context,
    writer: mutable TWriter<JSONID, JSONFile>,
    key: JSONID,
    values: mutable NonEmptyIterator<JSONFile>,
  ): void {
    applyMapFun(this.getId(), context, writer, key.value, values)
  }

  fun lazy(
    context: mutable Context,
    self: LHandle<JSONID, JSONFile>,
    key: JSONID,
  ): Array<JSONFile> {
    Array[JSONFile(applyLazyFun(this.getId(), context, self, key.value))]
  }

  fun params(context: mutable Context, key: JSONID): SKJSON.CJSON {
    applyParamsFun(this.getId(), context, key.value)
  }

  fun callAsync(
    name: String,
    call: String,
    key: JSONID,
    params: SKJSON.CJSON,
  ): void {
    applyLazyAsyncFun(this.getId(), call, name, key.value, params)
  }

  fun mapTable(
    context: mutable Context,
    writer: mutable TWriter<JSONID, JSONFile>,
    row: SKDB.RowValues,
  ): void {
    applyMapTableFun(
      this.getId(),
      context,
      writer,
      DBUtils.toCJArray(row),
      row.repeat.toFloat(),
    )
  }

  fun toRow(
    key: JSONID,
    values: mutable NonEmptyIterator<JSONFile>,
  ): SKJSON.CJSON {
    applyConvertToRowFun(this.getId(), key.value, values)
  }
}

class ExternAccumulator(
  accumulator: FnHandle,
) extends Accumulator<JSONFile, JSONFile> {
  //
  fun getType(): File ~> JSONFile {
    JSONFile::type
  }

  fun accumulate(acc: JSONFile, value: JSONFile): JSONFile {
    JSONFile(applyAccumulate(this.accumulator.getId(), acc.value, value.value))
  }

  fun dismiss(cumul: JSONFile, value: JSONFile): ?JSONFile {
    applyDismiss(this.accumulator.getId(), cumul.value, value.value).map(v ->
      JSONFile(v)
    )
  }
}

@export("SKIP_SKStore_map")
fun map(
  context: mutable Context,
  handleId: String,
  name: String,
  fnPtr: UInt32,
): String {
  eager = EHandle(JSONID::keyType, JSONFile::type, DirName::create(handleId));
  mapHandle = FnHandle::make(fnPtr);
  eagerMap(eager, JSONID::keyType, JSONFile::type, name, context, mapHandle.map)
    .getDirName()
    .toString()
}

@export("SKIP_SKStore_mapReduce")
fun mapReduce(
  context: mutable Context,
  handleId: String,
  name: String,
  fnPtr: UInt32,
  accumulator: UInt32,
  default: SKJSON.CJSON,
): String {
  eager = EHandle(JSONID::keyType, JSONFile::type, DirName::create(handleId));
  mapHandle = FnHandle::make(fnPtr);
  accumulatorHandle = FnHandle::make(accumulator);
  eagerMapReduce(
    eager,
    JSONID::keyType,
    JSONFile::type,
    name,
    context,
    mapHandle.map,
    ExternAccumulator(accumulatorHandle, JSONFile(default)),
  )
    .getDirName()
    .toString()
}

@export("SKIP_SKStore_multimap")
fun multimap(
  context: mutable Context,
  name: String,
  mappings: SKJSON.CJArray,
): String {
  skmappings = mappings match {
  | SKJSON.CJArray(v) ->
    v.map(e -> {
      mapping = SKJSON.expectArray(e);
      handleId = SKJSON.asString(mapping[0]);
      eager = EHandle(
        JSONID::keyType,
        JSONFile::type,
        DirName::create(handleId),
      );
      mapHandle = FnHandle::make(
        UInt32::truncate(SKJSON.asFloat(mapping[1]).toInt()),
      );
      return (eager, mapHandle.map)
    })
  };
  eagerMultiMap(JSONID::keyType, JSONFile::type, name, context, skmappings)
    .getDirName()
    .toString()
}

@export("SKIP_SKStore_multimapReduce")
fun multimapReduce(
  context: mutable Context,
  name: String,
  mappings: SKJSON.CJArray,
  accumulator: UInt32,
  default: SKJSON.CJSON,
): String {
  accumulatorHandle = FnHandle::make(accumulator);
  skmappings = mappings match {
  | SKJSON.CJArray(v) ->
    v.map(e -> {
      mapping = SKJSON.expectArray(e);
      handleId = SKJSON.asString(mapping[0]);
      eager = EHandle(
        JSONID::keyType,
        JSONFile::type,
        DirName::create(handleId),
      );
      mapHandle = FnHandle::make(
        UInt32::truncate(SKJSON.asFloat(mapping[1]).toInt()),
      );
      return (eager, mapHandle.map)
    })
  };
  eagerMultiMapReduce(
    JSONID::keyType,
    JSONFile::type,
    name,
    context,
    skmappings,
    ExternAccumulator(accumulatorHandle, JSONFile(default)),
  )
    .getDirName()
    .toString()
}

class AsyncValueSaveError(
  key: SKJSON.CJSON,
  params: SKJSON.CJSON,
  reason: String,
) extends .Exception {
  fun getMessage(): String {
    `Unable to save async result for key '${this.key.toJSON()}' and params '${this.params.toJSON()}: ${
      this.reason
    }'.`
  }
}

@export("SKIP_SKStore_asyncResult")
fun asyncResult(
  callId: String,
  lazyName: String,
  key: SKJSON.CJSON,
  params: SKJSON.CJSON,
  value: SKJSON.CJObject,
): Float {
  SKStore.runWithResult(context ~> {
    resultsDirs = DirName::create(lazyName + "sk_prv/results/");
    context.unsafeMaybeGetEagerDir(resultsDirs) match {
    | Some(dir) ->
      if (!dir.isInput()) {
        throw AsyncValueSaveError(key, params, "Invalid async handle")
      };
      keyId = JSONID(key);
      current = dir.getArray(context, keyId).map(JSONFile::type);
      if (current.isEmpty()) {
        throw AsyncValueSaveError(key, params, "Query info not found")
      };
      cvalue = current[0].value match {
      | x @ SKJSON.CJObject _ -> x
      | _ -> throw AsyncValueSaveError(key, params, "Invalid query info")
      };
      ksuid = SKJSON.getString(cvalue, "ksuid");
      if (!ksuid.map(v -> callId == v).default(false)) {
        // The received response is deprecated
        return void;
      };
      status = SKJSON.getString(value, "status") match {
      | Some(s) -> s
      | _ -> throw AsyncValueSaveError(key, params, "Invalid async result")
      };
      toAdd = status match {
      | "success" -> Array[("params", params)]
      | "failure" ->
        previous(cvalue) match {
        | Some(p) -> Array[("params", params), ("previous", p)]
        | _ -> Array[("params", params)]
        }
      | "unchanged" ->
        previous(cvalue) match {
        | Some(p) -> Array[("params", params), ("previous", p)]
        | _ -> Array[("params", params)]
        }
      | _ ->
        throw AsyncValueSaveError(key, params, `Unknown status '${status}'`)
      };
      toRegister = SKJSON.add(value, toAdd);
      dir.writeArray(context, keyId, Array[JSONFile(toRegister)])
    | None() ->
      throw AsyncValueSaveError(key, params, "Async handle not exist.")
    };
    context.update();
  }) match {
  | Success _ -> 1.0
  | Failure(err) -> -getErrorHdl(err)
  };
}

@export("SKIP_SKStore_fromSkdb")
fun mapTable(
  context: mutable Context,
  table: String,
  name: String,
  fnPtr: UInt32,
): String {
  mapHandle = FnHandle::make(fnPtr);
  DBUtils.mapTable(table, name, context, mapHandle.mapTable)
}

@export("SKIP_SKStore_toSkdb")
fun toSkdb(
  context: mutable Context,
  handleId: String,
  table: String,
  convPtr: UInt32,
): void {
  eager = EHandle(JSONID::keyType, JSONFile::type, DirName::create(handleId));
  mapHandle = FnHandle::make(convPtr);
  DBUtils.toTable(eager, table, context, mapHandle.toRow)
}

@export("SKIP_SKStore_get")
fun get(
  context: mutable Context,
  handleId: String,
  key: SKJSON.CJSON,
): SKJSON.CJSON {
  eager = EHandle(JSONID::keyType, JSONFile::type, DirName::create(handleId));
  eager.get(context, JSONID(key)).value
}

@export("SKIP_SKStore_getFromTable")
fun getFromTable(
  _context: mutable Context,
  _table: String,
  _key: SKJSON.CJSON,
  _index: SKJSON.CJSON,
): SKJSON.CJSON {
  invariant_violation("TODO")
}

@export("SKIP_SKStore_maybeGet")
fun maybeGet(
  context: mutable Context,
  handleId: String,
  key: SKJSON.CJSON,
): SKJSON.CJSON {
  eager = EHandle(JSONID::keyType, JSONFile::type, DirName::create(handleId));
  eager
    .maybeGet(context, JSONID(key))
    .map(v -> v.value)
    .default(SKJSON.CJNull())
}

@export("SKIP_SKStore_getLazy")
fun getLazy(
  context: mutable Context,
  handleId: String,
  key: SKJSON.CJSON,
): SKJSON.CJSON {
  lazy = LHandle(JSONID::keyType, JSONFile::type, DirName::create(handleId));
  getSelf(context, lazy, key)
}

@export("SKIP_SKStore_getSelf")
fun getSelf(
  context: mutable Context,
  handle: LHandle<JSONID, JSONFile>,
  key: SKJSON.CJSON,
): SKJSON.CJSON {
  handle.get(context, JSONID(key)).value
}

@export("SKIP_SKStore_size")
fun size(context: mutable Context, handleId: String): Float {
  eager = EHandle(JSONID::keyType, JSONFile::type, DirName::create(handleId));
  eager.size(context).toFloat()
}

@export("SKIP_SKStore_input")
fun input(
  context: mutable Context,
  name: String,
  values: SKJSON.CJArray,
): String {
  makeInput(
    JSONID::keyType,
    JSONFile::type,
    context,
    name,
    SKJSON.expectArray(values).map(v -> {
      a = SKJSON.expectArray(v);
      (JSONID(a[0]), JSONFile(a[1]))
    }),
  )
}

@export("SKIP_SKStore_lazy")
fun lazy(context: mutable Context, name: String, lazyFunPtr: UInt32): String {
  lazyHandle = FnHandle::make(lazyFunPtr);
  makeLazy(JSONID::keyType, JSONFile::type, context, name, lazyHandle.lazy)
}

@export("SKIP_SKStore_asyncLazy")
fun asyncLazy(
  context: mutable Context,
  name: String,
  getFunPtr: UInt32,
  lazyFunPtr: UInt32,
): String {
  getHandle = FnHandle::make(getFunPtr);
  lazyHandle = FnHandle::make(lazyFunPtr);
  fieldFilter = f ~> f != "params" && f != "ksuid";
  check: (JSONFile, SKJSON.CJSON) ~> Check<JSONFile> = (v, params) ~> {
    v.value match {
    | obj @ SKJSON.CJObject _ ->
      if (
        SKJSON.getValue(obj, "params").map(ps -> ps == params).default(false)
      ) {
        Check(true, Some(JSONFile(SKJSON.filter(obj, fieldFilter))))
      } else {
        Check(false, previous(obj).map(e -> JSONFile(e)))
      }
    | _ -> Check(false, None())
    }
  };
  loading: (String, SKJSON.CJSON, ?JSONFile) ~> Loading<JSONFile> = (
    ksuid,
    params,
    optPrevious,
  ) ~> {
    fields: Array<(String, SKJSON.CJSON)> = optPrevious.map(v ->
      v.value
    ) match {
    | Some(p) ->
      Array[
        ("ksuid", SKJSON.CJString(ksuid)),
        ("params", params),
        ("previous", p),
        ("status", SKJSON.CJString("loading")),
      ]
    | _ ->
      Array[
        ("ksuid", SKJSON.CJString(ksuid)),
        ("params", params),
        ("status", SKJSON.CJString("loading")),
      ]
    };
    internal = SKJSON.CJObject(SKJSON.CJFields::create(fields, x -> x));
    Loading(JSONFile(internal), JSONFile(SKJSON.filter(internal, fieldFilter)))
  };
  makeAsyncLazy<JSONID, JSONFile, SKJSON.CJSON>(
    JSONID::keyType,
    JSONFile::type,
    context,
    name,
    getHandle.params,
    lazyHandle.callAsync,
    check,
    loading,
  )
}

fun initCtx(): Context {
  Context{}
}

@export("SKIP_SKStore_createFor")
fun tsCreateFor(session: String): Float {
  createFor(session)
}

fun previous(value: SKJSON.CJObject): ?SKJSON.CJSON {
  if (SKJSON.getString(value, "status") == Some("success")) {
    Some(SKJSON.filter(value, f ~> f == "playload" || f == "metadata"))
  } else {
    SKJSON.getValue(value, "previous")
  }
}

@cpp_export("SKIP_SKStore_nameForMeta")
fun nameForMeta(script: String, line: Int, column: Int): String {
  toEncode = `${script}:${line}:${column}`;
  encoded = `b64_${Base64.encodeString(toEncode, true)}`;
  encoded.searchRight(ch ~> ch != '=') match {
  | Some(i) ->
    _ = i.next();
    encoded.getIter().substring(i)
  | None() -> ""
  }
}

fun toValues(
  entry: Array<SKJSON.CJSON>,
  prefix: String = "",
): (String, Vector<(String, SKJSON.CJSON)>) {
  exprs = mutable Vector<String>[];
  params = mutable Vector<(String, SKJSON.CJSON)>[];
  for (i in Range(0, entry.size())) {
    field = entry[i];
    field match {
    | SKJSON.CJString _
    | SKJSON.CJFloat _
    | SKJSON.CJInt _
    | SKJSON.CJBool _ ->
      params.push((`${prefix}${i}`, field))
    | _ ->
      params.push((`${prefix}${i}`, SKJSON.CJString(field.toJSON().toString())))
    };
    exprs.push(`@${prefix}${i}`);
  };
  (exprs.join(" , "), params.chill());
}

fun toSelectWhere(
  select: SKJSON.CJObject,
  prefix: String = "",
): (String, Vector<(String, SKJSON.CJSON)>) {
  select match {
  | SKJSON.CJObject(fields) ->
    if (fields.isEmpty()) {
      ("true", Vector[])
    } else {
      exprs = mutable Vector<String>[];
      params = mutable Vector<(String, SKJSON.CJSON)>[];
      fields.cols.eachWithIndex((idx, col) -> {
        fields.values[idx] match {
        | SKJSON.CJArray(arr) ->
          inVal = mutable Vector<String>[];
          for (jdx in Range(0, arr.size())) {
            pName = `${prefix}${jdx}_${col}`;
            params.push((pName, arr[jdx]));
            inVal.push(`@${pName}`);
          };
          exprs.push(`${col} IN (${inVal.join(", ")})`)
        | field ->
          pName = `${prefix}_${col}`;
          params.push((pName, field));
          exprs.push(`${col} = @${pName}`)
        }
      });
      (exprs.join(" AND "), params.chill())
    }
  }
}

fun toWhere(
  strColumns: String,
  entry: SKJSON.CJArray,
  prefix: String,
): (String, Vector<(String, SKJSON.CJSON)>) {
  columns = strColumns.split(",");
  entry match {
  | SKJSON.CJArray(earr) ->
    if (columns.size() != earr.size()) {
      throw invariant_violation("Invalid entry type.")
    };
    exprs = mutable Vector<String>[];
    params = mutable Vector<(String, SKJSON.CJSON)>[];
    for (i in Range(0, columns.size())) {
      col = columns[i];
      field = earr[i];
      field match {
      | SKJSON.CJArray(farr) ->
        inVal = mutable Vector<String>[];
        for (jdx in Range(0, farr.size())) {
          pName = `${prefix}${jdx}_${col}`;
          params.push((pName, farr[jdx]));
          inVal.push(`@${pName}`);
        };
        exprs.push(`${col} IN (${inVal.join(", ")})`)
      | _ ->
        pName = `${prefix}_${col}`;
        params.push((pName, field));
        exprs.push(`${col} = @${pName}`)
      }
    };
    (exprs.join(" AND "), params.chill())
  }
}

fun toSets(
  update: SKJSON.CJObject,
  prefix: String,
): (String, Vector<(String, SKJSON.CJSON)>) {
  exprs = mutable Vector<String>[];
  params = mutable Vector<(String, SKJSON.CJSON)>[];
  update match {
  | SKJSON.CJObject(fields) ->
    fields.cols.eachWithIndex((idx, column) -> {
      field = fields.values[idx];
      params.push((`${prefix}${column}`, field));
      exprs.push(`${column} = @${prefix}${column}`);
    })
  };
  (exprs.join(" , "), params.chill())
}

fun toInsertQuery(
  name: String,
  entries: SKJSON.CJArray,
  update: Bool,
): (String, Vector<(String, SKJSON.CJSON)>) {
  params = mutable Vector<(String, SKJSON.CJSON)>[];
  entries match {
  | SKJSON.CJArray(arr) ->
    values = arr.mapWithIndex((idx, vs) -> {
      (q, ps) = toValues(SKJSON.expectArray(vs), `v${idx}_`);
      ps.each(params.push);
      `(${q})`
    });
    (
      `INSERT ${if (update) "OR REPLACE " else {
        ""
      }}INTO "${name}" VALUES ${values.join(", ")};`,
      params.chill(),
    )
  }
}

fun toCreatesQuery(schemas: SKJSON.CJArray): Result<String, void> {
  vec = mutable Vector[];
  schemas match {
  | SKJSON.CJArray(ss) ->
    for (schema in ss) {
      SKJSON.optObject(schema) match {
      | Some(table) ->
        strcreate = toCreateQuery(table)?;
        vec.push(strcreate)
      | _ -> return Failure(void)
      }
    }
  };
  Success(vec.join("\n"));
}

fun toCreateQuery(table: SKJSON.CJObject): Result<String, void> {
  SKJSON.getString(table, "name") match {
  | Some(name) ->
    SKJSON.getArray(table, "expected") match {
    | Some(cols) ->
      strcolumns = toColumns(cols)?;
      Success(`CREATE TABLE IF NOT EXISTS "${name}" ${strcolumns};`)
    | _ -> Failure(void)
    }
  | _ -> Failure(void)
  };
}

fun toUpdateQuery(
  name: String,
  columns: String,
  entry: SKJSON.CJArray,
  updates: SKJSON.CJObject,
): (String, Vector<(String, SKJSON.CJSON)>) {
  params = mutable Vector<(String, SKJSON.CJSON)>[];
  (where, wps) = toWhere(columns, entry, "w_");
  wps.each(params.push);
  (sets, sps) = toSets(updates, "u_");
  sps.each(params.push);
  (`UPDATE "${name}" SET ${sets} WHERE ${where};`, params.chill())
}

fun toColumns(columns: SKJSON.CJArray): Result<String, void> {
  vec = mutable Vector[];
  columns match {
  | SKJSON.CJArray(cs) ->
    for (column in cs) {
      SKJSON.optObject(column) match {
      | Some(obj) ->
        strCol = toColumn(obj)?;
        vec.push(strCol)
      | _ -> return Failure(void)
      }
    }
  };
  Success(`(${vec.join(",")})`);
}

fun toColumn(column: SKJSON.CJObject): Result<String, void> {
  SKJSON.getString(column, "name") match {
  | Some(name) ->
    SKJSON.getString(column, "type") match {
    | Some(type) ->
      notnull = if (SKJSON.getBool(column, "notnull")) " NOT NULL" else "";
      primary = if (SKJSON.getBool(column, "primary")) " PRIMARY KEY" else "";
      Success(`${name} ${type}${notnull}${primary}`)
    | _ -> Failure(void)
    }
  | _ -> Failure(void)
  }
}

fun toUpdateWhereQuery(
  name: String,
  where: SKJSON.CJObject,
  updates: SKJSON.CJObject,
): (String, Vector<(String, SKJSON.CJSON)>) {
  params = mutable Vector<(String, SKJSON.CJSON)>[];
  (qWhere, wps) = toSelectWhere(where, "uw_");
  wps.each(params.push);
  (sets, sps) = toSets(updates, "us_");
  sps.each(params.push);
  (`UPDATE "${name}" SET ${sets} WHERE ${qWhere};`, params.chill())
}

fun toSelectQuery(
  name: String,
  select: SKJSON.CJObject,
  columns: SKJSON.CJArray,
): (String, Vector<(String, SKJSON.CJSON)>) {
  (w, ps) = toSelectWhere(select, "s_");
  (strColumns, orderBy) = columns match {
  | SKJSON.CJArray(arr) if (arr.isEmpty()) -> ("*", "")
  | SKJSON.CJArray(arr) ->
    strColumns = arr.map(SKJSON.asString);
    (
      strColumns.join(", "),
      ` ORDER BY ${strColumns.map(n -> `${n} ASC`).join(", ")}`,
    )
  };
  (`SELECT ${strColumns} FROM "${name}" WHERE ${w}${orderBy};`, ps);
}

fun toDeleteQuery(
  name: String,
  columns: String,
  entry: SKJSON.CJArray,
): (String, Vector<(String, SKJSON.CJSON)>) {
  (where, wps) = toWhere(columns, entry, "");
  (`DELETE FROM "${name}" WHERE ${where};`, wps)
}

fun toDeleteWhereQuery(
  name: String,
  where: SKJSON.CJObject,
): (String, Vector<(String, SKJSON.CJSON)>) {
  (qWhere, wps) = toSelectWhere(where, "d_");
  (`DELETE FROM "${name}" WHERE ${qWhere};`, wps)
}

fun execQuery(supplier: () ~> (String, Vector<(String, SKJSON.CJSON)>)): Float {
  try {
    (query, params) = supplier();
    DBUtils.execQuery(query, params) match {
    | Success _ -> 1.0
    | Failure(CRuntimeError(code, optMessage)) ->
      -getErrorHdl(Error(optMessage.default(`Runtime error ${code}`)))
    | Failure(e) -> -getErrorHdl(e)
    }
  } catch {
  | e -> -getErrorHdl(e)
  }
}

@export("SKIP_SKStore_insert")
fun insert(name: String, entries: SKJSON.CJArray, update: UInt32): Float {
  execQuery(() ~> toInsertQuery(name, entries, update != 0))
}

@export("SKIP_SKStore_createTables")
fun createTables(schemas: SKJSON.CJArray): Float {
  toCreatesQuery(schemas) match {
  | Success(query) -> execQuery(() ~> (query, Vector[]))
  | _ -> -getErrorHdl(Error("Unable to create tables: Invalid schemas."))
  }
}

@export("SKIP_SKStore_update")
fun update(
  name: String,
  columns: String,
  entry: SKJSON.CJArray,
  updates: SKJSON.CJObject,
): Float {
  execQuery(() ~> toUpdateQuery(name, columns, entry, updates))
}

@export("SKIP_SKStore_updateWhere")
fun updateWhere(
  name: String,
  where: SKJSON.CJObject,
  updates: SKJSON.CJObject,
): Float {
  execQuery(() ~> toUpdateWhereQuery(name, where, updates))
}

@export("SKIP_SKStore_select")
fun select(
  name: String,
  select: SKJSON.CJObject,
  columns: SKJSON.CJArray,
): Float {
  try {
    (query, params) = toSelectQuery(name, select, columns);
    DBUtils.execQuery(query, params) match {
    | Success _ -> 1.0
    | Failure(CRuntimeError(code, optMessage)) ->
      -getErrorHdl(Error(optMessage.default(`Runtime error ${code}`)))
    | Failure(e) -> -getErrorHdl(e)
    }
  } catch {
  | e -> -getErrorHdl(e)
  }
}

@export("SKIP_SKStore_delete")
fun delete(name: String, columns: String, entry: SKJSON.CJArray): Float {
  execQuery(() ~> toDeleteQuery(name, columns, entry))
}

@export("SKIP_SKStore_deleteWhere")
fun deleteWhere(name: String, where: SKJSON.CJObject): Float {
  execQuery(() ~> toDeleteWhereQuery(name, where))
}

class ExternalException(
  type: String,
  message: String,
  stack: String,
) extends .Exception {
  fun getMessage(): String {
    `${this.type}: ${this.message}'.`
  }
}

@export("SKIP_SKStore_throwExternalException")
fun throwExternalException(type: String, message: String, stack: String): void {
  throw ExternalException(type, message, stack);
}

@export("SKIP_SKStore_getExceptionStack")
fun getExceptionStack(e: .Exception): String {
  e match {
  | ExternalException(_t, _m, stack) -> stack
  | _ -> ""
  }
}

module end; /* SKStore */
